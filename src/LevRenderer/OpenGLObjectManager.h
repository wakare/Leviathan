#pragma once

#include <gl/glew.h>
#include <map>
#include "LSPtr.h"
#include "LevTextureObject.h"
#include "OpenGLRenderBackend.h"

namespace Leviathan
{
	namespace Renderer
	{
		class IOpenGLTextureObject;
		class OpenGLRenderBackend;

		class OpenGLObjectManager
		{
		public:
			OpenGLObjectManager(OpenGLRenderBackend& render_backend);

			/*
			 ***************************************** Resource generation
			 * Every object resource should be generated by Object Manager.
			 */
			bool CreateTextureResource(Scene::LevTextureType tex_type, GLuint texture_object_uid, GLuint width, GLuint height, GLuint depth, const GLvoid* data, LSPtr<IOpenGLTextureObject>& out);

			bool GetTextureResource(GLuint texture_object_uid, LSPtr<IOpenGLTextureObject>& out);

			template<typename LAMBDA_TYPE>
			bool PushRenderCommand(LAMBDA_TYPE command, OpenGLCommandType type);

			bool FlushRenderCommand();

		private:
			OpenGLRenderBackend& m_render_backend;

			std::map<GLuint, LSPtr<IOpenGLTextureObject>> m_texture_objects;
		};

		template <typename LAMBDA_TYPE>
		bool OpenGLObjectManager::PushRenderCommand(LAMBDA_TYPE command, OpenGLCommandType type)
		{
			m_render_backend.PushRenderCommand(command, type);
			return true;
		}
	}
}
